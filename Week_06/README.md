第六周学习笔记

本周学习了动态规划的相关知识。
动态规划的三个步骤：
1. 分解子问题
2. 定义状态数组
3. DP方程

爬楼梯问题：
如果使用递归的话，时间复杂度时指数级的2^n
``` Java
int fib(int n) {
  return n <= 1 ? n : fib(n - 1) + fib(n - 2);
}
```

在上面的基础上，可以加上一个缓存，时间复杂度就会从指数级减低到O（n）
``` Java
int fib(int n, int[]memo) {  //Memoization记忆化搜索
  if(n <= 1) return n;
  if(memo[n] == 0)
    memo[n] = fib(n - 1) + fib(n - 2);
  return memo[n];
}
```

自底向上BottomUp的写法如下：
``` Java
int fib(int n) {
  int [] a = new int[n+1];
  a[0] = 0, a[1] = 1;
  for(int i = 2; i <= n ; i++) {
    a[i] = a[i - 1] + a[i - 2];
  }
  return a[n];
}
```

如第二种解法一样，从根节点一直探索到叶子节点，由于叶子节点的值是确定的，n <= 1，直接return n，从顶到下，这是一种自顶向下的写法。
但是也可以递推，由于知道 n <= 1，所以从0到n的值可以由前面两个值确定，这就是自顶向上。
如果对于一个熟练的选手，要追求DP功力比较深厚，尤其是在计算机竞赛的时候，只要开始写递归的话，所有的竞赛型选手全都开始for循环，也就是全部都是自底向上的写循环，这也就是DP很多时候翻译成动态递推的这个原因。对于初学者来说，可以先用自己习惯的思维方式进行分治和记忆化，最后再转换成递推。

一般对于动态规划的题目，第一步就是找出他的子问题，接着定义状态数组最后得出动态方程。找重复性是比较难的，目前只能多做一点题目，来锻炼自己。不过对于关于字符串的题目，一般都是可以定义一个二维数组进行状态的记录，并且子问题可以通过切分字符串进行划分。