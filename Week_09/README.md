第九周学习笔记
1. 复习了一遍动态规划。找最近最简方法，类比成找最大公约数。
2. 动态规划和分治其实没有非常显著或者本质上的区别。当是当分治的子问题具有重叠的话，或者是最优子结构的时候，这个时候就能去重或者淘汰次优解。在这种办法，如果能在每一步淘汰次优解的话，就变成了所谓的动态规划。
3. 分治再加上记忆化的缓存的话，这个时候就可以认为已经从分治过渡到动态规划了。

动态规划：
1. 第一步分解为一个简单的子问题
2. 分治+最优子结构
3. 顺推形式： 动态递推（也就是从下往上推）这就很像Fibinnac数列，与其不如从f（6）往下走，还不如就从下标为01234，一直用Fibonacci数列的递推公式往上递推。最后就变成循环。
4. 初学者可以从分治+记忆化搜索来开始切入动态规划的题目，然后在转换成递推的问题。
5. 如果熟悉了之后就可以使用递推的形式进行解答。

``` Java
Dp递推模板
int[][] dp = new int[N+1][M+1];
for(int i = 0 ; i < N; ++i) {
    for(int j = 0; j < M; ++j)
        dp[i][j] = _Function(dp[i..][j..]...)
} 

return dp[N][M];
```

1. 模板的定义并不复杂，复杂的地方是DP状态的定义，需要一定的经验，同时需要将现实的问题定义成为一个数组，里面保存状态。数组可以是一维，二维，三维。
2. DP的状态方程要怎么写，这是个难题。但是更多情况下，我们会求一个最小值，或者是我们可以累加累减，或者是在里面有一层的小循环，从之前k个状态里面找出它的最值。

关键点
1. 动态规划和递归和分治没有根本上的区别（关键看有无最优的子结构）
2. 拥有共性：找到重复子问题

差异性：最优子结构，中途可以淘汰次优解

字符串Immutable与mutable
Java的字符串属于Immutable，指的是不变的。

Rabin-Karp算法
KMP算法

